package new_viewer;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Map.Entry;

import serieparallel.Graph;
import serieparallel.Node;
import serieparallel.Pair;

public class PositionSerieParallelAlgo {

    Graph sp;
    private ArrayList<Node<?>> nodeOnYaxis[];
    private float[] next;
    private float[] offset;
    private int graphDepth;
    
    private Deque<Integer> forks;
    private Deque<Node<?>> forkNodes;
    
    private ArrayList<Pair<Node<?>, Node<?>>> pairs;
    boolean b = false;
    
    
    
    public PositionSerieParallelAlgo(Graph graph) {
        this.sp=graph;
        forks = new LinkedList<>();
        forkNodes = new LinkedList<>();
        pairs = new ArrayList<>();
        //Trouver la profondeur
        //System.out.println("mxFIND DEPTH STARTED");
        for(Node<?> node : sp.getSources()) {
            findDepthMax(node, 0);
        }
        //System.out.println("depth :"+graphDepth);
        //System.out.println("mxFIND DEPTH ENDED");
        next = new float[graphDepth+1];
        offset = new float[graphDepth+1];
        //draw(mxGraph.getSources().get(0), null);
        nodeOnYaxis = new ArrayList[graphDepth+1];
        for(int i=0;i<nodeOnYaxis.length;i++)
            nodeOnYaxis[i] = new ArrayList<Node<?>>();
        
        run();
        for(int i = forks.size(); i > 0 ; i--) {
            System.out.println(forkNodes.pop()+" is a fork of "+forks.pop());
        }
    }
    
    
    
    public void run() {
        try {
            for(Node<?> node : sp.getSources()) {
                System.out.println("mxPLACE FATHERS STARTED");
                placeOrdonnee(node,0);
                placeFathers(node);
                System.out.println("mxPLACE FATHERS ENDED");
            }
            for(Node<?> node : sp.getSources()) {
                //enfantsUnique(node);
                applyOffsets(node, 0);
            }
            for(Pair<Node<?>,Node<?>> p : pairs) {
                Node<?> node = (Node<?>) p.getN1();
                node.offset = Math.abs(p.getN2().x - node.x); 
            }
            
            
            for(Node<?> node : sp.getSources()) {
//              System.out.println("mxPLACE SONS STARTED");
//              placeSons(node);
//              System.out.println("mxPLACE SONS ENDED");
                computePairs(node, 0);
            }
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        for(Pair p : pairs) {
            System.out.println(p.toString());
        }
    }
    
    private void enfantsUnique(Node<?> node) {
        boolean enfantUnique = true;
        for(Node<?> parent : node.getParents())
            if(parent.getChildren().size()>1) {
                enfantUnique = false;
                break;
            }
          if(enfantUnique && node.getParents().size()>=1) {
                node.offset = Math.abs((float) ((node.getParents().get(0).x + node.getParents().get(node.getParents().size()-1).x) / 2.0) - node.x);
            }
          for(Node<?> child : node.getChildren())
              enfantsUnique(child);
    }
    
    private void applyOffsets(Node<?> node, float offsum) {
        if(node.tag==1) {
            node.x += offsum;
            offsum += node.offset;
            
            node.offset = 0;
            node.tag=0;
            for(Node<?> child : node.getChildren()) {
                applyOffsets(child, offsum);
            }
            }
    }



    private void findDepthMax(Node<?> Node, int depth) {
        for(Node<?> child : Node.getChildren()) {
            findDepthMax(child, depth+1);
        }
        if(graphDepth<depth) graphDepth=depth;
    }
/*  
    private void placeFathers(Node<?> node, int depth) throws InterruptedException {
        //System.out.println("(Fathers) Node : "+node.id);
        //Placer l'ordonnée
        
        if(depth>node.y) {
            if(!nodeOnYaxis[depth].contains(node)) 
                nodeOnYaxis[depth].add(node);
            node.y = depth;
        }

        for(Node<?> child : node.getChildren()) {
            placeFathers(child, depth+1);
        }
        
        //Calcul position parent par rapport fils
        int nbChildren = node.getChildren().size(); 
        float place = 0;
        if (nbChildren == 0) {
            place = next[depth];
        } else {
            //System.out.println(node.getValue()+" between "+node.getChildren().get(0).value+" and "+node.getChildren().get(nbChildren-1).value);
            place = (float) ((node.getChildren().get(0).x + node.getChildren().get(nbChildren-1).x) / 2.0);
        }

        //calcul éventuel décalage engendré. Si on l'a décalé à cause de ses fils.
        offset[depth] = Math.max(offset[depth], next[depth]-place);
        
        //Application décalage profondeur.
        //if(place > node.x) {
            node.x = place + offset[depth];
        //}
        
        //maj prochaine place disponible à cette profondeur.
        
            
        next[depth] = Math.max(next[depth], node.x+1);
        int nbParents = node.getParents().size();
        if(node.tag==0) {
//          System.out.println("parcours: "+node.id);
//          if(nbChildren>1) {
//              if(!b) {
//                  forks.add(nbChildren);
//                  forkNodes.add(node);
//                  System.out.println("push fork"+nbChildren+" : "+node.id);
//                  b=true; // fork
//              }else{
//                  int newval = forks.poll()+nbChildren-1;
//                  forks.add(newval);
//                  System.out.println("maj to "+newval);
//              }
//          }
//          if(nbParents>1) {
//              joins.add(nbParents);
//              joinNodes.add(node);
//              b=false;
//              System.out.println("push join"+nbParents+" : "+node.id);
//          }
            
            if(nbParents>1) { //IF JOIN AND CUR_DIAMOND
//              if(!joins.isEmpty()) {
//                  Integer n = joins.pop();
//                  n += nbParents - 1;
//                  joins.add(n);
//              }
//          } else if(nbParents > 1) { //IF JOIN AND NOT CUR_DIAMOND
//              joins.add(nbParents);
//              joinNodes.add(node);
//          }
//          
//          if(nbChildren > 1) { //IF FORK AND CUR DIAMOND
//              Integer n = forks.pop();
//              n += nbChildren - 1;
//              forks.add(n);
//              forkNodes.pop(); //On oublie l'ancien
//              forkNodes.add(node);
//              //compare();
//          } else if(nbChildren > 1) { //IF FORK AND NOT CUR DIAMOND
//              forks.add(nbChildren);
//              forkNodes.add(node);
                //compare();
            }
        }
        
        
        // On mémorise le décalage à appliquer au sous-arbre lors de la deuxième passe.
        //node.offset = offset[depth];  
        node.tag=1;
    }
    private void placeSons(Node<?> node) {              
        //System.out.println("(Sons) Node : "+node.id);
        if(node.tag==1) {
            if(node.getParents().size() > 1) {
                //forks.pop();
                //node.x = forkNodes.pop().x;
            }
        }
        
        node.tag=0;

        
        for(Node<?> child : node.getChildren()) {
            placeSons(child);
        }
        for(int i = 0; i<forks.size(); i++) {
            System.out.println("fork : "+forks.pop()+" : "+forkNodes.pop().id);
        }
        for(int i = 0; i<joins.size(); i++) {
            System.out.println("join : "+joins.pop()+" : "+joinNodes.pop().id);
        }
        
        
    }*/
    private void placeOrdonnee(Node<?> node, int depth) {
        //Placer l'ordonnée
        if(depth>node.y) {
        if(!nodeOnYaxis[depth].contains(node))  //On n'a pas remove dans nodeOnAxis[node.y] ??
            nodeOnYaxis[depth].add(node);
            node.y = depth;
        }

        for(Node<?> child : node.getChildren()) {
            placeOrdonnee(child, depth+1);
        }
    }
    
    private void placeFathers(Node<?> node) throws InterruptedException {
        boolean parentsAreVisited = true;
        for(int i = 0; i < node.getParents().size() ; i++) {
            if(node.getParents().get(i).visited == false) {
                parentsAreVisited = false;
                break;
            }
        }
        if(parentsAreVisited) {
            System.out.println("parcours de "+node.id+" : "+node.x);
            node.visited = true;
            updateStacks(node);
        }
        

        for(Node<?> child : node.getChildren()) {
            placeFathers(child);
        }
        
        if(node.tag==0) {
//          
//          float place;
//          if(node.getChildren().size()>0)
//              place =  (float) ((node.getChildren().get(0).x + node.getChildren().get(node.getChildren().size()-1).x) / 2.0);
//          else
//              place = next[(int)node.y];
//          
//          node.x = Math.max(next[(int)node.y], place);
//
//          next[(int)node.y] = node.x+1;
//          node.tag = 1;
//      }
        //Calcul position parent par rapport fils
            
            
                int nbChildren = node.getChildren().size(); 
                float placeSouhaite = 0;
                if (nbChildren == 0) {
                    placeSouhaite = next[(int)node.y];
                }else {
                    //System.out.println(node.getValue()+" between "+node.getChildren().get(0).value+" and "+node.getChildren().get(nbChildren-1).value);
                    placeSouhaite = (float) ((node.getChildren().get(0).x + node.getChildren().get(nbChildren-1).x) / 2.0);
                }

                //calcul éventuel décalage engendré. Si on l'a décalé à cause de ses fils.
                /*offset[(int)node.y] = Math.max(offset[(int)node.y], next[(int)node.y]-placeSouhaite);
                
                //Application décalage profondeur.
                //if(place > node.x) {
                    node.x = placeSouhaite + offset[(int)node.y];
                //}
                
                //maj prochaine place disponible à cette profondeur.
                
                next[(int)node.y] = Math.max(next[(int)node.y], node.x+1);
                node.offset = offset[(int)node.y];
                node.tag = 1;
                */
                
                node.x = Math.max(placeSouhaite, next[(int)node.y]);// + offset[(int)node.y];
                
                //maj prochaine place disponible à cette profondeur.
                
                next[(int)node.y] = Math.max(next[(int)node.y], node.x+1);
                node.offset = Math.abs(node.x - placeSouhaite);//offset[(int)node.y];
                node.tag = 1;
                 
        }
    }



    private void updateStacks(Node<?> node) {
        if(node.getParents().size() > 1) { //Si c'est un join
            int joinSize = node.getParents().size();
            while(joinSize > 0) {
                Node<?> fork = forkNodes.removeLast();
                int forkValue = forks.removeLast();
                if(joinSize == forkValue) {
                    pairs.add(new Pair<Node<?>, Node<?>>(node, fork));
                    break;
                }
                else if(joinSize > forkValue) {
                    joinSize = joinSize - forkValue + 1;
                }else {
                    System.out.println("join tout seul : "+node);
                    forkNodes.addLast(fork);
                    forks.addLast(forkValue - joinSize +1);
                    break;
                }
            }
        }
        
        if(node.getChildren().size() > 1) { //C'est un fork
            forkNodes.addLast(node);
            forks.addLast(node.getChildren().size());
        }
        
    }
    
    /*
     * def addOffsets (self, offsum=0):
        self.x = self.x + offsum
        offsum = offsum + self.offset
        
        self.height = self.y
        self.width = self.x
        
        for c in self.children:
            c.addOffsets(offsum)
            self.height = max (self.height, c.height)
            self.width = max (self.width, c.width)
     */
    
    private void computePairs(Node<?> node, float offsum) {
        if(node.tag==0) {
            if(node.offset!=0)
                offsum = node.offset;
        node.x += offsum;
        node.tag=1;
        for(Node<?> child : node.getChildren()) {
            computePairs(child, offsum);
        }
        }
    }

    
}
